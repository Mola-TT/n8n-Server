---
description: 
globs: 
alwaysApply: true
---
# Milestone

## Milestone 8 (Current)
- Create `backup_config.sh` under setup folder that:
  - Implements automated n8n data backups (workflows, credentials, encryption keys)
  - Backs up user files directory (`/opt/n8n/files/`)
  - Backs up per-user data directories (`/opt/n8n/users/`)
  - Backs up Docker configuration and environment files
  - Backs up SSL certificates and nginx configuration
  - Configured rotational backup strategy with daily, weekly, and monthly retention
  - Implements backup compression (tar.gz) to minimize storage requirements
  - Configures secure backup storage with proper permissions
  - Creates email notifications for backup success/failure
  - Implements backup verification to ensure data integrity
  - Adds backup encryption options for sensitive data (GPG)
  - Supports both local and remote backup destinations (S3, SFTP)
  - Backs up Redis data for queue persistence
- Create backup management scripts under `/opt/n8n/scripts/`:
  - `backup_now.sh` - Manual trigger for immediate backup
  - `list_backups.sh` - List available backup points with sizes and dates
  - `restore_backup.sh` - Restore n8n from specific backup point
  - `verify_backup.sh` - Verify backup integrity and completeness
  - `cleanup_backups.sh` - Manage backup retention and cleanup old backups
- Implement automatic backup cleanup:
  - Schedule automated cleanup via systemd timer (runs after backup job)
  - Apply retention policies: keep X daily, Y weekly, Z monthly backups
  - Implement storage threshold cleanup (auto-delete oldest when disk usage > threshold)
  - Verify backup count before cleanup (never delete if below minimum retention)
  - Log all cleanup actions with backup names, sizes, and reasons
  - Send email summary of deleted backups
  - Support dry-run mode to preview cleanup without deletion
  - Clean up both local and remote backups based on policies
- Create comprehensive test script (`test_backup.sh`) to validate:
  - Backup creation for all n8n data directories
  - Backup scheduling via cron/systemd timers
  - Backup rotation and retention policies
  - Backup compression and encryption
  - Backup restoration process with service stop/start
  - Docker volume backup and restore
  - Email notifications for backup events
  - Remote backup upload (if configured)
  - Automatic cleanup execution and scheduling
  - Retention policy enforcement (daily/weekly/monthly)
  - Storage threshold cleanup trigger
  - Minimum backup preservation (never delete below MIN_KEEP)
  - Cleanup dry-run mode verification
- Update environment configuration:
  - Add backup-specific settings to default.env and user.env.template
  - Add BACKUP_SCHEDULE (cron format for backup job)
  - Add BACKUP_CLEANUP_SCHEDULE (cron format for cleanup job)
  - Add BACKUP_RETENTION_DAILY, BACKUP_RETENTION_WEEKLY, BACKUP_RETENTION_MONTHLY
  - Add BACKUP_MIN_KEEP (minimum backups to always retain)
  - Add BACKUP_STORAGE_THRESHOLD (percentage, trigger cleanup when exceeded)
  - Add BACKUP_LOCATION (local path)
  - Add BACKUP_REMOTE_ENABLED, BACKUP_REMOTE_TYPE (s3/sftp)
  - Add BACKUP_ENCRYPTION_ENABLED, BACKUP_ENCRYPTION_KEY
  - Add BACKUP_EMAIL_NOTIFY (true/false)
- Implement backup monitoring:
  - Add Netdata dashboard for backup status and history
  - Create backup health checks (last successful backup age)
  - Implement backup size and growth trend monitoring
  - Add backup failure alerting via email
  - Monitor backup storage space usage
- Create backup documentation (`README-Backup.md`):
  - Document backup strategy and retention policies
  - Provide restore procedures for different scenarios
  - Include disaster recovery guidelines
  - Document backup verification process
  - Provide troubleshooting guide for backup issues

## Milestone 7 (Completed)
- Create `multi_user_config.sh` under setup folder that:
  - Implements multi-user n8n architecture with isolated user directories
  - Creates per-user folder structure under `/opt/n8n/users/[user_id]/`
  - Configures user-specific data isolation within single n8n instance
  - Implements user session management and authentication
  - Sets up user-specific workflow and credential storage
  - Configures per-user file storage directories
  - Creates user provisioning and deprovisioning automation
  - Implements user access control and permission management
- Create `iframe_embedding_config.sh` under setup folder that:
  - Configures n8n for secure iframe embedding in external web applications
  - Sets up CORS policies for cross-origin iframe access
  - Implements Content Security Policy (CSP) headers for iframe security
  - Configures X-Frame-Options for selective iframe embedding
  - Sets up authentication token passing between parent app and n8n
  - Implements session synchronization between web app and embedded n8n
  - Configures URL path routing for user-specific iframe access
  - Sets up postMessage API for parent-child window communication
- Create `user_monitoring.sh` under setup folder that:
  - Implements per-user execution time tracking and reporting
  - Monitors storage usage per user with quotas and alerts
  - Tracks workflow execution statistics per user
  - Implements user resource usage analytics and billing data
  - Creates performance metrics collection per user
  - Sets up user-specific log aggregation and analysis
  - Implements automated cleanup for inactive users
  - Configures user usage dashboards in Netdata
- Create `cross_server_setup.sh` under setup folder that:
  - Configures secure communication between web app server and n8n server
  - Sets up API authentication for cross-server requests
  - Implements webhook forwarding and callback mechanisms
  - Configures network security between servers (VPN/firewall rules)
  - Sets up load balancing for multiple n8n server instances
  - Implements health checks and failover mechanisms
  - Configures shared session storage across servers
  - Sets up secure file transfer mechanisms between servers
- Update Nginx configuration for multi-user support:
  - Implement user-specific URL routing and access control
  - Configure rate limiting per user to prevent abuse
  - Implement user session management through proxy headers
  - Configure proxy rules for iframe embedding requirements
  - Set up user-specific access logging and monitoring
  - Configure WebSocket support for user sessions
  - Implement security headers for user isolation
  - Set up user authentication middleware integration
- Update Docker configuration for multi-user architecture:
  - Configure shared n8n instance with user isolation
  - Implement user-specific volume mounting for data directories
  - Set up user permission management within container
  - Configure resource monitoring per user within single instance
  - Implement user session management in containerized environment
  - Set up user-specific environment variable injection
  - Configure logging separation per user
  - Implement user cleanup and maintenance automation
- Create comprehensive user management API:
  - Implement REST API for user provisioning/deprovisioning
  - Create user authentication and authorization endpoints
  - Set up user configuration management via API
  - Implement user usage reporting and analytics API
  - Create user backup and restore API endpoints
  - Set up user data migration and export capabilities
  - Implement user access control and permission management
  - Create API documentation and integration examples
- Create cross-server documentation (`README-WebApp-Server.md`):
  - Document web app server requirements and dependencies
  - Provide step-by-step setup instructions for embedding n8n
  - Include iframe integration code examples and best practices
  - Document authentication flow between web app and n8n server
  - Provide security considerations and CORS configuration
  - Include troubleshooting guide for common integration issues
  - Document API endpoints for user management
  - Provide performance optimization recommendations
- Create comprehensive test scripts:
  - `test_multi_user.sh` - Validate multi-user isolation and routing
  - `test_iframe_embedding.sh` - Test iframe integration and security
  - `test_user_monitoring.sh` - Validate metrics collection and reporting
  - `test_cross_server.sh` - Test communication between servers
  - `test_user_api.sh` - Validate user management API endpoints
  - `test_performance_metrics.sh` - Test execution time and storage tracking
  - `test_user_scaling.sh` - Validate user management and resource allocation
- Enhanced environment configuration:
  - Add multi-user specific configuration variables
  - Add iframe embedding security settings
  - Add cross-server communication configuration
  - Add user resource limits and quotas
  - Add monitoring and analytics preferences
  - Add user cleanup and maintenance schedules
  - Add API authentication and security settings
- Performance and Analytics Features:
  - Real-time execution time measurement per workflow
  - Storage usage tracking with automated cleanup policies
  - User performance benchmarking and optimization
  - Predictive analytics for resource scaling
  - Cost analysis and billing data generation
  - User usage patterns analysis and reporting
  - Performance bottleneck identification and alerts
  - Resource utilization forecasting per user

## Milestone 6 (Completed)
- Create `dynamic_optimization.sh` under setup folder that:
  - Detects hardware specifications (CPU cores, memory, disk size)
  - Dynamically calculates optimal n8n configuration parameters
  - Dynamically calculates optimal Docker resource limits and allocations
  - Dynamically calculates optimal Nginx worker processes and connections
  - Dynamically calculates optimal Redis memory configuration
  - Implements intelligent resource allocation based on available hardware
  - Provides performance recommendations based on n8n workload patterns
  - Creates monitoring hooks to detect performance bottlenecks
  - Optimizes PostgreSQL connection parameters for external database
- Create `hardware_change_detector.sh` under setup folder that:
  - Implements a service to monitor for hardware changes (CPU, RAM, disk)
  - Triggers automatic reconfiguration when hardware changes are detected
  - Records previous vs. new hardware specifications for comparison
  - Performs gradual/phased optimization during production hours
  - Creates backup of previous configuration before applying changes
  - Implements robust email notification system for hardware changes
  - Provides multiple fallback methods for n8n data directory detection
  - Includes test email functionality to verify email configuration
- Update n8n configuration for dynamic scaling:
  - Implement dynamic N8N_EXECUTION_PROCESS based on CPU cores
  - Configure N8N_EXECUTION_TIMEOUT based on available memory
  - Adjust Docker memory limits based on total system memory
  - Optimize worker processes for workflow execution
  - Configure queue settings based on Redis memory allocation
  - Implement dynamic webhook timeout configuration
  - Tune database connection pool size for external PostgreSQL
- Update Docker configuration for dynamic scaling:
  - Dynamically adjust container memory limits based on available RAM
  - Calculate optimal CPU limits based on core count
  - Implement dynamic shared memory configuration
  - Configure restart policies based on system stability
  - Optimize volume mount performance based on disk I/O capabilities
  - Implement dynamic logging configuration to prevent disk overflow
- Update Nginx configuration for dynamic scaling:
  - Dynamically adjust worker_processes based on CPU cores
  - Calculate optimal worker_connections based on system resources
  - Implement dynamic client_max_body_size for file uploads
  - Configure proxy timeouts based on n8n execution patterns
  - Optimize SSL session cache based on available memory
  - Tune keepalive settings based on connection patterns
- Update Redis configuration for dynamic scaling:
  - Dynamically adjust maxmemory based on available RAM
  - Calculate optimal maxmemory-policy for n8n queue management
  - Implement dynamic save configuration based on disk I/O
  - Configure timeout settings based on n8n workflow patterns
  - Optimize persistence settings based on reliability requirements
- Update Netdata configuration for dynamic scaling:
  - Dynamically adjust update frequency based on system load
  - Configure memory usage limits based on available RAM
  - Implement dynamic alert thresholds based on hardware capacity
  - Optimize data retention based on disk space
  - Configure streaming settings for multi-server environments
- Create comprehensive test script (`test_dynamic_optimization.sh`) to validate:
  - Correct parameter calculations for different hardware profiles
  - Proper configuration file generation and application
  - Performance improvements after optimization
  - Correct behavior during hardware change simulations
  - Resource utilization before and after optimization
  - n8n workflow execution performance improvements
- Create comprehensive test script (`test_email_notification.sh`) to validate:
  - Email notifications for hardware changes
  - Email notifications for optimization completion
  - Basic test email functionality
  - Proper email tool installation and configuration
  - Fallback mechanisms for email sending
- Create comprehensive test script (`test_hardware_change_detector.sh`) to validate:
  - Hardware change detection accuracy
  - Automatic reconfiguration triggers
  - Backup and restore functionality
  - Service monitoring and restart capabilities
  - Hardware specification comparison logic
  - Gradual optimization scheduling
- Create integration test script (`test_optimization.sh`) to validate:
  - End-to-end optimization workflow
  - Cross-component configuration consistency
  - Performance impact measurement
  - System stability after optimization
  - Rollback mechanisms and recovery procedures
  - Multi-component service coordination
- Update test runner (`run_tests.sh`) to include:
  - All Milestone 6 test scripts in proper execution order
  - Hardware simulation test environments
  - Performance benchmarking capabilities
  - Test result aggregation and reporting
  - Integration with existing test infrastructure
- Create analytics and reporting for optimization:
  - Generate optimization reports with before/after comparisons
  - Visualize performance metrics through Netdata dashboards
  - Implement predictive analysis for future resource needs
  - Create alerting system for approaching resource limits
  - Document optimization decisions and rationale
  - Monitor n8n workflow execution performance trends
  - Track Docker container resource utilization patterns
- Enhanced environment configuration:
  - Added email notification settings to environment files
  - Added TEST_EMAIL_SUBJECT variable for email testing
  - Implemented backward compatibility with existing email settings
  - Unified email configuration across different components
  - Added hardware optimization preferences and thresholds
  - Configured performance monitoring and alerting parameters

## Milestone 5 (Completed)
- Created `ssl_renewal.sh` under setup folder that:
  - Set up automatic renewal of Let's Encrypt SSL certificates for production environments
  - Handle self-signed certificate management when PRODUCTION=false
  - Configured proper renewal hooks to restart/reload Nginx and related services after renewal
  - Implemented fallback mechanisms for when Let's Encrypt renewal might fail
  - Created detailed logging for renewal processes and certificate management
  - Ensured proper file permissions for certificate files in both production and development modes
  - Included graceful error handling with clear error messages
  - Configured different certificate approaches based on PRODUCTION flag (Let's Encrypt vs self-signed)
  - Added special handling for DNS propagation delays in Cloudflare DNS validation for production
  - Implemented development mode with self-signed certificate regeneration when needed
  - Integrated with existing Nginx SSL configuration for seamless certificate updates
- Created comprehensive test script (`test_ssl_renewal.sh`) to validate:
  - Proper certificate renewal configuration for production environments
  - Self-signed certificate handling for development environments (PRODUCTION=false)
  - Renewal hooks functionality and service restart capabilities
  - Proper permissions on SSL certificate files for both Nginx and n8n access
  - Simulated renewal process with dry-run for Let's Encrypt certificates
  - Log file creation and error reporting for certificate management
  - Added specific handling for development vs production environment differences
  - Provided detailed diagnostics for renewal simulation failures
  - Validated integration with existing Nginx reverse proxy configuration
  - Test script for the SSL renewal function to ensure proper operation
  - Automated testing of certificate renewal workflows without affecting production certificates
- Updated init.sh and related scripts:
  - Added SSL renewal configuration in the initialization process
  - Enhanced integration with existing Nginx SSL setup from Milestone 3
  - Improved certificate management workflow for both development and production
  - Added certificate validation and automatic regeneration capabilities
- Enhanced error handling and logging:
  - Implemented detailed error reporting for certificate renewal and generation failures
  - Added verification steps for SSL certificate configuration
  - Created troubleshooting guidance in log messages for certificate issues
  - Added validation checks to prevent common SSL certificate problems
  - Enhanced logging to distinguish between production Let's Encrypt and development self-signed workflows
  - Created helper functions for certificate management operations
- SSL Certificate Management Features:
  - Automatic Let's Encrypt certificate acquisition and renewal for production environments
  - Self-signed certificate generation and management for development environments (PRODUCTION=false)
  - Seamless integration with existing Nginx reverse proxy from Milestone 3
  - Certificate validation and health checking capabilities
  - Proper certificate file permissions for multi-service access (Nginx, n8n, Netdata)
  - Backup and recovery mechanisms for certificate files
  - Support for multiple domain configurations and certificate types

## Milestone 4 (Completed)
- Created `netdata_config.sh` under setup folder that:
  - Installs Netdata for system resource monitoring
  - Configures Netdata to listen only on localhost for security
  - Sets up Nginx as a secure HTTPS proxy for Netdata dashboard access
  - Implements basic authentication for Netdata web interface
  - Configures SSL using Let's Encrypt certificates with proper staging/production environment support
  - Creates health alert notifications for CPU, RAM, and disk usage thresholds at 80%
  - Configures email alerts when system resources exceed thresholds
  - Configures firewall rules to block direct access to Netdata port (19999)
- Created comprehensive test script (`test_netdata.sh`) to validate:
  - Internal Netdata accessibility on localhost
  - External Netdata accessibility via HTTPS proxy
  - Authentication with proper credentials
  - HTTP to HTTPS redirection
  - Firewall configuration blocking direct access
- Enhanced environment configuration:
  - Added Netdata-specific settings to environment files
  - Added email notification configuration options
  - Added PRODUCTION flag to control Let's Encrypt staging vs production environments
  - Added secure credential storage mechanisms
- Improved error handling and logging:
  - Implemented detailed error reporting for certificate acquisition failures
  - Added proper service status verification
  - Fixed configuration bugs related to WebSocket support
  - Added troubleshooting guidance in log messages
- Final Implementation and Testing:
  - Fixed Netdata health alerts with correct chart names (system.cpu, system.ram, disk_space./, system.load)
  - Implemented missing email notification configuration
  - Resolved sudo privileges and package manager issues
  - Suppressed verbose package installation output for cleaner logs
  - Achieved 100% test coverage: 56/56 tests passing
  - All Netdata monitoring features fully operational and validated

## Milestone 3 (Completed)
- Created `nginx_config.sh` under setup folder with comprehensive functionality:
  - Install and configure Nginx as a secure reverse proxy for n8n
  - Configure SSL certificates:
    - Production mode: Ready for Let's Encrypt integration (placeholder implemented)
    - Development mode: Self-signed certificates automatically generated
    - SSL certificate validation properly configured for development vs production
  - Configure firewall rules to expose Nginx ports (80/443) with UFW integration
  - All connections to n8n routed through HTTPS with HTTP to HTTPS redirects
  - Robust error handling and silent installation implemented
  - Nginx configuration optimized for n8n reverse proxy with security headers
- Updated `init.sh` to include complete Nginx configuration in initialization process
- Enhanced environment configuration:
  - Added Nginx-specific settings to default.env and user.env.template
  - Added SSL certificate configuration options with proper path handling
  - Implemented development vs production mode detection and configuration
- SSL Certificate Management:
  - Created SSL renewal script placeholder (`ssl-renew.sh`) for future implementation
  - Proper SSL certificate path configuration based on deployment mode
  - SSL certificates stored in `/etc/nginx/ssl/` for Nginx and `/opt/n8n/ssl/` for n8n
- Firewall and Security:
  - UFW firewall configuration with SSH (22), HTTP (80), and HTTPS (443) ports
  - Firewall status monitoring and summarized logging
  - Security headers configured in Nginx for enhanced protection
- Integration and Architecture:
  - Complete integration with Docker infrastructure (Milestone 2)
  - n8n runs in HTTP mode while Nginx handles SSL termination
  - Seamless end-to-end HTTPS access via reverse proxy

## Milestone 2 (Completed)
- Created comprehensive n8n Docker infrastructure:
  - Complete directory structure on host:
    - `/opt/n8n/docker/` → for config files (docker-compose.yml, .env)
    - `/opt/n8n/files/` → mapped as internal /data/files for file storage
    - `/opt/n8n/.n8n/` → persistent home directory for n8n metadata (workflows, credentials)
    - `/opt/n8n/logs/` → for application logs
    - `/opt/n8n/backups/` → for backup storage
    - `/opt/n8n/scripts/` → for operational scripts
    - `/opt/n8n/ssl/` → for SSL certificates
  - Proper permissions and ownership configuration for Docker operations
- Created production-ready docker-compose.yml file in `/opt/n8n/docker/`:
  - n8n service with `n8nio/n8n:latest` image
  - Port mapping: `5678:5678` for internal HTTP communication
  - Environment file mapping with comprehensive configuration
  - Volume mounts:
    - `/opt/n8n/files` → `/data/files`
    - `/opt/n8n/.n8n` → `/home/node/.n8n`
    - `/opt/n8n/ssl` → `/opt/ssl:ro` (read-only SSL certificates)
  - Restart policy: `unless-stopped` for high availability
  - Network configuration with dedicated `n8n-network`
- External PostgreSQL database integration:
  - PostgreSQL connection variables in environment file
  - Database configuration passed to n8n container
  - SSL configuration for database connections with certificate validation handling
  - Connection testing and validation in test suite
- Redis service implementation:
  - Redis container (`redis:7-alpine`) added to docker-compose
  - Redis configured for n8n queue management
  - Redis data persistence with named volume `redis-data`
  - Health checks and connectivity verification
- User management and permissions:
  - Docker group membership configuration
  - Proper file ownership for n8n directories (`user:docker`)
  - Permission handling for both root and non-root execution
- Operational maintenance scripts:
  - `/opt/n8n/scripts/cleanup.sh` - Automated cleanup for Docker images and logs
  - `/opt/n8n/scripts/update.sh` - n8n container update management
  - `/opt/n8n/scripts/service.sh` - Service control (start/stop/restart/status/logs)
  - Log rotation and cleanup policies implementation
- Timezone configuration:
  - Proper timezone configuration for scheduled workflows
  - Timezone environment variables for containers
  - System timezone synchronization
- Container Management:
  - Automatic container startup after infrastructure setup
  - Container health verification and status monitoring
  - Service response verification (n8n web interface accessibility)
- Systemd Integration:
  - Created `n8n-docker.service` for system-level management
  - Auto-start configuration and service enablement
  - Proper service lifecycle management
- Environment Configuration:
  - Dynamic environment file generation based on user configuration
  - Development vs production mode handling
  - Database SSL configuration with proper certificate validation
  - n8n HTTP mode configuration when using Nginx reverse proxy
- Docker Infrastructure Tests:
  - n8n Directory Structure validation
  - Directory Permissions verification
  - Docker Compose File validation
  - Environment File configuration testing
  - Redis Configuration verification
  - Operational Scripts testing
  - Systemd Service validation
  - Docker Installation verification
  - Volume Mounts testing
  - Network Configuration validation
- n8n Application Tests:
  - n8n Environment Configuration testing
  - Authentication Configuration validation
  - Timezone Configuration verification
  - SSL Configuration testing
  - SSL Certificates validation
  - PostgreSQL Connectivity testing
  - Database Permissions verification
  - n8n Container Health monitoring
  - Redis Connectivity testing
  - n8n Web Accessibility verification
  - Authentication Challenge testing
  - Authentication Login validation

## Milestone 1 (Completed)
- Created comprehensive `init.sh` script with full orchestration:
  - Updates Ubuntu server silently with progress indication
  - Sets up timezone directly from configuration with validation
  - Root privilege checking and user safety
  - Environment variable loading with override logic
  - Complete initialization flow covering all milestones
  - Script executable permission management
  - Integration with test suite for validation
- Created robust `logger.sh` script with advanced logging:
  - Color-coded log levels (DEBUG, INFO, WARNING, ERROR, PASS)
  - Bold timestamps for better readability
  - White log messages with colored level indicators
  - File logging capability with log rotation
  - Consistent logging format: [YYYY-MM-DD HH:MM:SS] [LEVEL] message
- Environment configuration system:
  - `default.env` with comprehensive default configuration
  - `user.env.template` for user-specific customization
  - Environment variable override logic with precedence handling
  - Development vs production mode configuration
- Utility functions in `utilities.sh`:
  - `execute_silently` for quiet command execution
  - Log file management and cleanup utilities
  - Error handling and validation functions
- General configuration in `general_config.sh`:
  - System update functionality with silent operation
  - Timezone configuration with validation
  - Package management and prerequisite installation
- Basic Infrastructure Tests:
  - Directory structure validation
  - Required files existence checking
  - Script permissions verification
  - User environment handling testing
  - Environment loading validation
  - Logging functions testing
  - Utility functions verification
- Test Infrastructure:
  - Test runner (`run_tests.sh`) with organized test execution
  - Consistent test output formatting with visual separators
  - Clean test result presentation with proper sectioning
- Logging and Output Improvements:
  - Consistent separator lines for visual organization
  - Header lines print directly (no timestamps) for better formatting
  - Parsed and summarized status outputs (firewall, container status)
  - Professional output formatting with proper visual separation

## Development Standards Maintained
- Minimal Code Principle - No unnecessary complexity
- Direct Implementation - Shortest and clearest approach
- Single Source of Truth - All logic in main scripts
- NO HOTFIXES - All fixes implemented directly in main scripts
- Logical Commits - Meaningful, focused commits with clear messages
- Immediate Commits - Changes committed after each feature completion
- Proper Version Control - Clean development history maintained